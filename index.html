<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EXCELERATE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; user-select: none; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        
        /* Text Styles */
        .hud-text { color: white; text-shadow: 0 0 10px rgba(255,255,255,0.8); letter-spacing: 2px; }
        #score-display { font-size: 2rem; font-weight: bold; }
        #streak-bar-container { width: 100%; height: 10px; background: rgba(255,255,255,0.2); margin-top: 10px; border-radius: 5px; overflow: hidden; }
        #streak-bar { width: 0%; height: 100%; background: white; box-shadow: 0 0 15px white; transition: width 0.1s linear; }
        
        /* Menus */
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; pointer-events: auto; backdrop-filter: blur(5px); }
        h1 { color: white; font-size: 4rem; text-transform: uppercase; margin: 0; text-shadow: 0 0 20px white; font-style: italic; }
        .sub-text { color: #aaa; margin-top: 10px; font-size: 1.2rem; }
        #high-score-label { color: gold; margin-top: 20px; font-size: 1.5rem; text-shadow: 0 0 10px orange; }
        
        /* Buttons */
        .btn { border: 2px solid white; color: white; background: transparent; padding: 15px 40px; font-size: 1.5rem; margin-top: 30px; cursor: pointer; transition: 0.2s; font-family: inherit; text-transform: uppercase; font-weight: bold; }
        .btn:hover { background: white; color: black; box-shadow: 0 0 20px white; }
        
        #mute-btn { pointer-events: auto; background: transparent; border: 1px solid rgba(255,255,255,0.5); color: white; padding: 10px; font-family: inherit; cursor: pointer; opacity: 0.7; }
        #mute-btn:hover { opacity: 1; border-color: white; }

        /* Canvas scaling for pixel look is handled by ThreeJS, but we ensure crisp rendering here too */
        canvas { image-rendering: pixelated; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div>
            <div id="score-display">SPEED: 0%</div>
            <div id="streak-bar-container"><div id="streak-bar"></div></div>
        </div>
        <div style="text-align: right;">
            <button id="mute-btn">MUTE MUSIC</button>
        </div>
    </div>

    <div id="start-screen">
        <h1>Excelerate</h1>
        <div class="sub-text">TAP / SPACE to Switch Direction</div>
        <div class="sub-text">Avoid Obstacles to Build Speed</div>
        <div id="high-score-label">BEST STREAK: 0</div>
        <button id="start-btn" class="btn">IGNITE</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';

        // --- CONFIGURATION ---
        // !!! UPDATE THIS LIST WITH YOUR ACTUAL FILE NAMES FROM YOUR GITHUB !!!
        const REPO_URL = "https://raw.githubusercontent.com/Jackboby/EXCELERATE/main/Song/";
        const SONG_FILES = [
            "Psalm23.mp3", // Replace with your real filenames
            "Isaiah40.mp3"
        ];
        
        const COLOR_PALETTES = [
            { main: 0xFFFF00, bg: 0x222200 }, // Yellow Theme
            { main: 0x00FFFF, bg: 0x002222 }, // Cyan Theme
            { main: 0xFF00FF, bg: 0x220022 }, // Magenta Theme
            { main: 0x00FF00, bg: 0x002200 }  // Green Theme
        ];

        // --- GAME STATE ---
        let isPlaying = false;
        let isMuted = false;
        let score = 0;
        let highScore = localStorage.getItem('excelerate_highscore') || 0;
        
        // Physics / Gameplay
        let gameSpeed = 0;
        const BASE_SPEED = 0.5;
        const MAX_SPEED = 4.0;
        const ACCELERATION = 0.001; 
        
        let playerDir = 1; // 1 = Right, -1 = Left
        const PLAYER_LATERAL_SPEED = 0.4;
        const LANE_WIDTH = 12;

        // Objects
        const obstacles = [];
        let obstacleTimer = 0;

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        // Fog for depth and color blending
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 12);
        camera.lookAt(0, 0, -5);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- AUDIO SYSTEM ---
        const audioListener = new THREE.AudioListener();
        camera.add(audioListener);
        const bgmSound = new THREE.Audio(audioListener);
        
        let currentSongIndex = -1;

        async function playRandomMusic() {
            if(bgmSound.isPlaying) bgmSound.stop();
            
            // Pick random song different from current
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * SONG_FILES.length);
            } while (newIndex === currentSongIndex && SONG_FILES.length > 1);
            
            currentSongIndex = newIndex;
            const songName = SONG_FILES[currentSongIndex];
            
            // Apply color theme based on song index (wrapping around if more songs than palettes)
            applyTheme(currentSongIndex % COLOR_PALETTES.length);

            if(isMuted) return;

            const loader = new THREE.AudioLoader();
            try {
                // Using Raw GitHub URL
                const buffer = await loader.loadAsync(REPO_URL + songName);
                bgmSound.setBuffer(buffer);
                bgmSound.setLoop(true);
                bgmSound.setVolume(0.5);
                bgmSound.play();
            } catch (e) {
                console.warn("Could not load music. Check filenames.", e);
            }
        }

        // --- MATERIALS & LIGHTS ---
        // Player: White Diamond (Octahedron), Very Emissive (Glowing)
        const playerGeo = new THREE.OctahedronGeometry(0.8, 0);
        const playerMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff, 
            emissiveIntensity: 2.0,
            roughness: 0.1,
            metalness: 0.9
        });
        const player = new THREE.Mesh(playerGeo, playerMat);
        scene.add(player);

        // Floor Grid (Retro style)
        const gridHelper = new THREE.GridHelper(200, 50, 0xffffff, 0x444444);
        gridHelper.position.y = -1;
        gridHelper.position.z = -50;
        gridHelper.scale.z = 5; // Stretch it out
        scene.add(gridHelper);

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Directional Light
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);

        // --- POST PROCESSING (PIXEL + BLOOM) ---
        const composer = new EffectComposer(renderer);
        
        // 1. Pixelation Pass (The "Pixel Shader" look)
        // resolutionScale: 4 means the game renders at 1/4th resolution and scales up
        const renderPixelatedPass = new RenderPixelatedPass(4, scene, camera);
        composer.addPass(renderPixelatedPass);

        // 2. Bloom Pass (The "Shiny Whites")
        const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // High glow
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- FUNCTIONS ---

        function applyTheme(paletteIndex) {
            const palette = COLOR_PALETTES[paletteIndex];
            
            // Tween colors (simple immediate switch for now)
            scene.background = new THREE.Color(palette.bg);
            scene.fog.color.setHex(palette.bg);
            
            gridHelper.material.color.setHex(palette.main);
            bloomPass.tintColor = new THREE.Color(palette.main); // Custom tint logic could go here
            
            // Update UI color
            document.getElementById('score-display').style.color = new THREE.Color(palette.main).getStyle();
            document.getElementById('streak-bar').style.backgroundColor = "white"; // Keep bar white for contrast
            document.getElementById('streak-bar').style.boxShadow = `0 0 15px ${new THREE.Color(palette.main).getStyle()}`;
        }

        function createObstacle() {
            // Random size
            const size = 1 + Math.random() * 2;
            const geo = new THREE.BoxGeometry(size, size, size);
            
            // Material inherits current theme implicitly by lighting, but let's make them dark blocks with colored edges
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.2,
                emissive: scene.fog.color, // Glows slightly with theme color
                emissiveIntensity: 0.5
            });

            const mesh = new THREE.Mesh(geo, mat);
            
            // Random X position within lanes
            const xPos = (Math.random() - 0.5) * LANE_WIDTH * 1.5; 
            
            mesh.position.set(xPos, 0, -80); // Spawn far away
            scene.add(mesh);
            obstacles.push({ mesh, active: true });
        }

        function handleInput() {
            if (!isPlaying) return;
            playerDir *= -1; // Flip direction
            
            // Visual feedback: little rotation punch
            player.rotation.z = playerDir * 0.5; 
        }

        function updatePhysics() {
            if (!isPlaying) return;

            // 1. Accelerate Game Speed
            if (gameSpeed < MAX_SPEED) {
                gameSpeed += ACCELERATION;
            }

            // 2. Player Movement
            player.position.x += playerDir * PLAYER_LATERAL_SPEED;
            
            // Bounce off walls
            if (player.position.x > LANE_WIDTH) {
                player.position.x = LANE_WIDTH;
                playerDir = -1;
            } else if (player.position.x < -LANE_WIDTH) {
                player.position.x = -LANE_WIDTH;
                playerDir = 1;
            }

            // Rotate player for visuals
            player.rotation.y += 0.1;
            player.rotation.x += 0.05;
            // Lerp rotation Z back to 0
            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, 0, 0.1);

            // 3. Obstacle Logic
            obstacleTimer -= gameSpeed;
            if (obstacleTimer <= 0) {
                createObstacle();
                // Spawn rate increases with speed
                obstacleTimer = 40 / (gameSpeed + 0.1); 
            }

            // Move Grid to simulate speed
            gridHelper.position.z += gameSpeed;
            if(gridHelper.position.z > 0) gridHelper.position.z = -50;

            // Move & Check Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const ob = obstacles[i];
                ob.mesh.position.z += gameSpeed;

                // Collision Detection (Simple AABB approximation)
                // Player is approx size 1
                const distZ = Math.abs(ob.mesh.position.z - player.position.z);
                const distX = Math.abs(ob.mesh.position.x - player.position.x);
                
                // Hitbox size (average of box size)
                const hitSize = ob.mesh.geometry.parameters.width / 2 + 0.5;

                if (ob.active && distZ < hitSize && distX < hitSize) {
                    // --- COLLISION! ---
                    ob.active = false;
                    
                    // Bounce Player Back visually
                    player.position.z -= 2; 
                    
                    // Break Streak / Slow Down
                    gameSpeed = BASE_SPEED;
                    score = Math.floor(score * 0.5); // Penalty
                    
                    // Visual Shake
                    camera.position.x = (Math.random() - 0.5) * 2;
                    
                    // Flash screen red temporarily
                    const oldFog = scene.fog.color.getHex();
                    scene.fog.color.setHex(0xFF0000);
                    setTimeout(() => {
                         scene.fog.color.setHex(oldFog);
                    }, 100);

                } else if (ob.mesh.position.z > 15) {
                    // Passed camera
                    scene.remove(ob.mesh);
                    ob.mesh.geometry.dispose();
                    ob.mesh.material.dispose();
                    obstacles.splice(i, 1);
                }
            }

            // Lerp Player back to origin Z if they got bounced
            player.position.z = THREE.MathUtils.lerp(player.position.z, 0, 0.1);
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, 0, 0.1); // Stabilize camera
            
            // Score Update (Based on sustained speed)
            score += gameSpeed * 0.1;
            updateUI();
        }

        function updateUI() {
            // Speed percentage
            const speedPct = Math.floor((gameSpeed / MAX_SPEED) * 100);
            document.getElementById('score-display').innerText = `VELOCITY: ${speedPct}% | SCORE: ${Math.floor(score)}`;
            document.getElementById('streak-bar').style.width = `${speedPct}%`;
        }

        function saveGame() {
            if (score > highScore) {
                highScore = Math.floor(score);
                localStorage.setItem('excelerate_highscore', highScore);
            }
        }

        // --- INPUT HANDLING ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Mouse/Touch
        window.addEventListener('pointerdown', (e) => {
            if (e.target.id === 'start-btn') {
                startGame();
            } else if (e.target.id === 'mute-btn') {
                toggleMute();
            } else {
                handleInput();
            }
        });

        // Keyboard
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (!isPlaying && document.getElementById('start-screen').style.display !== 'none') {
                    startGame();
                } else {
                    handleInput();
                }
            }
        });

        function toggleMute() {
            isMuted = !isMuted;
            if (isMuted) {
                bgmSound.pause();
                document.getElementById('mute-btn').innerText = "UNMUTE";
            } else {
                bgmSound.play();
                document.getElementById('mute-btn').innerText = "MUTE MUSIC";
            }
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            isPlaying = true;
            score = 0;
            gameSpeed = BASE_SPEED;
            
            // Clean up old obstacles
            obstacles.forEach(o => scene.remove(o.mesh));
            obstacles.length = 0;
            
            playRandomMusic();
        }

        function gameOver() {
            // Logic if we wanted a hard game over, but requirements said bounce/slow down.
            // But if we stop playing:
            isPlaying = false;
            saveGame();
            document.getElementById('high-score-label').innerText = `BEST STREAK: ${highScore}`;
            document.getElementById('start-screen').style.display = 'flex';
        }

        // Init High Score UI
        document.getElementById('high-score-label').innerText = `BEST STREAK: ${highScore}`;

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            composer.render();
        }

        animate();

    </script>
</body>
</html>
