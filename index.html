<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EXCELERATE</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jersey+15&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: "Jersey 15", Courier, monospace; user-select: none; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; animation: subtleShake 1.8s infinite ease-in-out; }
        
        /* Text Styles */
        .hud-text { color: white; text-shadow: 0 0 10px rgba(255,255,255,0.8); letter-spacing: 2px; }
        #score-display { font-size: 2rem; font-weight: bold; transition: color 1s; }
        #status-display { font-size: 1.5rem; color: #00FFFF; font-weight: bold; text-shadow: 0 0 20px cyan; opacity: 0; transition: opacity 0.2s; }
        
        #streak-bar-container { width: 100%; height: 10px; background: rgba(255,255,255,0.2); margin-top: 10px; border-radius: 0px; overflow: hidden; }
        #streak-bar { width: 0%; height: 100%; background: white; box-shadow: 0 0 15px white; transition: width 0.1s linear; }

        /* SONG INDICATOR STYLES */
        #song-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
            margin-bottom: 15px;
            opacity: 0; /* Hidden initially */
        }
        
        #song-name {
            color: #fff;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
            text-transform: uppercase;
        }

        #song-icon {
            width: 40px;
            height: auto;
            border-radius: 0px;
        }

        /* Song Tick Animation */
        .tick-animation {
            animation: slideInTick 1s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }

        @keyframes slideInTick {
            0% { opacity: 0; transform: translateX(30px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        @keyframes subtleShake {
            0%   { transform: translate(0px, 0px) rotate(0deg); }
            25%  { transform: translate(0.4px, -0.4px) rotate(-0.04deg); }
            50%  { transform: translate(-0.4px, 0.4px) rotate(0.04deg); }
            75%  { transform: translate(0.4px, 0.4px) rotate(-0.04deg); }
            100% { transform: translate(0px, 0px) rotate(0deg); }
        }

        /* Common text elements */
        p, span, h1, h2, h3, h4, h5, h6, li, a, label, button, img {
          display: inline-block; 
          animation: subtleShake 1.8s infinite ease-in-out;
        }

        /* Menus */
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; pointer-events: auto; backdrop-filter: blur(5px); }
        h1 { color: white; font-size: 4rem; text-transform: uppercase; margin: 0; text-shadow: 0 0 20px white; font-style: italic; }
        .sub-text { color: #aaa; margin-top: 10px; font-size: 1.2rem; }
        #high-score-label { color: gold; margin-top: 20px; font-size: 1.5rem; text-shadow: 0 0 10px orange; animation: subtleShake 1.8s infinite ease-in-out; }
        
        /* Buttons */
        .btn { border: 2px solid white; color: white; background: transparent; padding: 15px 40px; font-size: 1.5rem; margin-top: 30px; cursor: pointer; transition: 0.2s; font-family: inherit; text-transform: uppercase; font-weight: bold; }
        .btn:hover { background: white; color: black; box-shadow: 0 0 20px white; }
        
        #mute-btn { pointer-events: auto; background: transparent; border: 3px solid rgba(255,255,255,0.5); color: white; padding: 10px; font-family: inherit; cursor: pointer; opacity: 0.7; animation: subtleShake 1.8s infinite ease-in-out; }
        #mute-btn:hover { opacity: 1; border-color: white; }

        canvas { image-rendering: pixelated; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div>
            <div id="score-display">SPEED: 0%</div>
            <div id="status-display">EXCELLING</div>
            <div id="streak-bar-container"><div id="streak-bar"></div></div>
        </div>
        
        <div style="text-align: right; display: flex; flex-direction: column; align-items: flex-end;">
            <div id="song-container">
                <span id="song-name"></span>
                <img id="song-icon" src="https://i.postimg.cc/vZZnW58X/Project-Name-419.gif" alt="music">
            </div>
            
            <button id="mute-btn">MUTE MUSIC</button>
        </div>
    </div>

    <div id="start-screen">
        <img src="https://i.postimg.cc/sXWb9KBR/Project-Name-418.png" width=400px;></img>
        <div class="sub-text">TAP / SPACE to Switch Direction</div>
        <div class="sub-text">Hit RINGS to Excel!</div>
        <div class="sub-text">Avoid Sin all-around.</div>
        <div id="high-score-label">BEST STREAK: 0</div>
        <button id="start-btn" class="btn">EXCEL</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';

        // --- CONFIGURATION ---
        // !!! UPDATE THIS LIST WITH YOUR ACTUAL FILE NAMES !!!
        const REPO_URL = "https://raw.githubusercontent.com/Jackboby/EXCELERATE/main/Song/";
        const SONG_FILES = [
            "Isaiah40.mp3", 
            "Psalm23.mp3",
            "Psalm115.mp3"
        ];
        
        const COLOR_PALETTES = [
            { main: 0xFFFF00, bg: 0x222200 }, // Yellow
            { main: 0x00FFFF, bg: 0x002222 }, // Cyan
            { main: 0xFF00FF, bg: 0x220022 }, // Magenta
            { main: 0x00FF00, bg: 0x002200 }, // Green
            { main: 0xFF4400, bg: 0x221100 }  // Orange
        ];

        // --- GAME STATE ---
        let isPlaying = false;
        let isMuted = false;
        let score = 0;
        
        // Local Storage Check
        let highScore = 0;
        try {
            highScore = parseFloat(localStorage.getItem('excelerate_highscore')) || 0;
        } catch(e) { console.warn("Local storage disabled"); }
        
        // Physics
        let gameSpeed = 0;
        const BASE_SPEED = 0.65;
        const MAX_SPEED = 4.5;
        const ACCELERATION = 0.0023; 
        
        let playerDir = 1; 
        const PLAYER_LATERAL_SPEED = 0.4;
        const LANE_WIDTH = 12;

        // Invincibility Logic
        let invincibleTimer = 0;
        const INVINCIBILITY_DURATION = 180; // Adjusted for roughly 3 seconds at 60fps

        // Object Management
        const obstacles = [];
        const rings = [];
        let spawnTimer = 0;

        // Colors
        const currentColor = {
            main: new THREE.Color(0xFFFFFF),
            bg: new THREE.Color(0x000000)
        };
        const targetColor = {
            main: new THREE.Color(0xFFFF00),
            bg: new THREE.Color(0x222200)
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 12);
        camera.lookAt(0, 0, -5);
        const baseFov = 70;

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- AUDIO SYSTEM ---
        const audioListener = new THREE.AudioListener();
        camera.add(audioListener);
        const bgmSound = new THREE.Audio(audioListener);
        let currentSongIndex = -1;
        let isLoadingMusic = false;

        async function playRandomMusic() {
            if(isLoadingMusic) return;
            isLoadingMusic = true;

            if(bgmSound.isPlaying) bgmSound.stop();
            
            let newIndex;
            if (SONG_FILES.length > 1) {
                do {
                    newIndex = Math.floor(Math.random() * SONG_FILES.length);
                } while (newIndex === currentSongIndex);
            } else {
                newIndex = 0;
            }
            
            currentSongIndex = newIndex;
            setThemeTarget(currentSongIndex % COLOR_PALETTES.length);

            // --- UI UPDATE FOR SONG ---
            const songContainer = document.getElementById('song-container');
            const songLabel = document.getElementById('song-name');
            
            // Format name: Remove .mp3 and insert space before numbers
            let rawName = SONG_FILES[currentSongIndex].replace('.mp3', '');
            let formattedName = rawName.replace(/(\D)(\d)/, '$1 $2');
            
            songLabel.innerText = formattedName;

            // Trigger Animation (Remove class -> Trigger Reflow -> Add class)
            songContainer.classList.remove('tick-animation');
            void songContainer.offsetWidth; 
            songContainer.classList.add('tick-animation');
            
            // ---------------------------

            if(isMuted) {
                isLoadingMusic = false;
                return;
            }

            const loader = new THREE.AudioLoader();
            try {
                const buffer = await loader.loadAsync(REPO_URL + SONG_FILES[currentSongIndex]);
                bgmSound.setBuffer(buffer);
                bgmSound.setLoop(false); 
                bgmSound.setVolume(0.5);
                bgmSound.play();
            } catch (e) {
                console.warn("Could not load music:", e);
            }
            isLoadingMusic = false;
        }

        // --- ASSETS & MATERIALS ---
        
        // Player
        const playerGeo = new THREE.OctahedronGeometry(0.8, 0);
        const playerMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff, 
            emissiveIntensity: 2.0,
            roughness: 0.1
        });
        const player = new THREE.Mesh(playerGeo, playerMat);
        scene.add(player);

        // Ring Geometry
        const ringGeo = new THREE.TorusGeometry(1.5, 0.2, 9, 5);
        const ringMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            emissive: 0xFFFFFF,
            emissiveIntensity: 3.0,
            roughness: 0.0
        });

        // Floor Grid
        const gridHelper = new THREE.GridHelper(200, 50, 0xffffff, 0x444444);
        gridHelper.position.y = -1;
        gridHelper.position.z = -50;
        gridHelper.scale.z = 5; 
        scene.add(gridHelper);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);

        // Post Processing
        const composer = new EffectComposer(renderer);
        const renderPixelatedPass = new RenderPixelatedPass(4, scene, camera);
        composer.addPass(renderPixelatedPass);

        const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
        bloomPass.threshold = 0;
        bloomPass.strength = 1.5; 
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- FUNCTIONS ---

        function setThemeTarget(paletteIndex) {
            const palette = COLOR_PALETTES[paletteIndex];
            targetColor.main.setHex(palette.main);
            targetColor.bg.setHex(palette.bg);
        }

        function createObject() {
            // Decide whether to spawn Ring (15%) or Obstacle (85%)
            const r = Math.random();
            const xPos = (Math.random() - 0.5) * LANE_WIDTH * 1.5; 

            if (r > 0.97) {
                // --- SPAWN RING ---
                const mesh = new THREE.Mesh(ringGeo, ringMat);
                mesh.position.set(xPos, 0.5, -120);
                mesh.rotation.y = Math.PI / 2; // Face camera roughly
                scene.add(mesh);
                rings.push({ mesh, active: true });
            } else {
                // --- SPAWN OBSTACLE ---
                const size = 1.5 + Math.random() * 1.5;
                const geo = new THREE.TetrahedronGeometry(size, 3);
                const mat = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Pure black
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                mesh.position.set(xPos, 0, -120); 
                scene.add(mesh);
                obstacles.push({ mesh, active: true });
            }
        }

        function updateColors() {
            const lerpSpeed = 0.02;
            currentColor.main.lerp(targetColor.main, lerpSpeed);
            currentColor.bg.lerp(targetColor.bg, lerpSpeed);

            scene.background.copy(currentColor.bg);
            scene.fog.color.copy(currentColor.bg);
            gridHelper.material.color.copy(currentColor.main);
            bloomPass.tintColor = currentColor.main;
            
            const uiColorString = currentColor.main.getStyle();
            document.getElementById('score-display').style.color = uiColorString;
            document.getElementById('streak-bar').style.boxShadow = `0 0 15px ${uiColorString}`;
        }

        function updatePhysics() {
            if (!isPlaying) return;

            // Invincibility Timer
            if (invincibleTimer > 0) {
                invincibleTimer--;
                document.getElementById('status-display').style.opacity = 1;
                // Widen FOV for speed effect
                camera.fov = THREE.MathUtils.lerp(camera.fov, baseFov + 15, 0.05);
            } else {
                document.getElementById('status-display').style.opacity = 0;
                // Return FOV to normal
                camera.fov = THREE.MathUtils.lerp(camera.fov, baseFov, 0.05);
            }
            camera.updateProjectionMatrix();

            // Base Acceleration
            if (gameSpeed < MAX_SPEED) gameSpeed += ACCELERATION;
            
            // Player Movement
            player.position.x += playerDir * PLAYER_LATERAL_SPEED;
            
            // Wall Bounds
            if (player.position.x > LANE_WIDTH) { player.position.x = LANE_WIDTH; playerDir = -1; } 
            else if (player.position.x < -LANE_WIDTH) { player.position.x = -LANE_WIDTH; playerDir = 1; }

            // Player visual spin
            player.rotation.y += 0.1 + (gameSpeed * 0.05); 
            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, 0, 0.1);

            // Spawning
            spawnTimer -= gameSpeed;
            if (spawnTimer <= 0) {
                createObject();
                spawnTimer = 40 / (gameSpeed + 0.1); 
            }

            // Grid Scroll
            gridHelper.position.z += gameSpeed;
            if(gridHelper.position.z > 0) gridHelper.position.z = -50;

            // --- OBSTACLES LOGIC ---
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const ob = obstacles[i];
                ob.mesh.position.z += gameSpeed;
                ob.mesh.rotation.x += 0.02; ob.mesh.rotation.y += 0.02;

                const distZ = Math.abs(ob.mesh.position.z - player.position.z);
                const distX = Math.abs(ob.mesh.position.x - player.position.x);
                const hitSize = 1.5;

                if (ob.active && distZ < hitSize && distX < hitSize) {
                    ob.active = false;
                    
                    if (invincibleTimer > 0) {
                        // --- SMASH THROUGH OBSTACLE ---
                        score += 100; // Bonus for smashing
                        scene.remove(ob.mesh); // Poof, gone
                    } else {
                        // --- HIT OBSTACLE (DAMAGE) ---
                        player.position.z -= 2; 
                        gameSpeed = BASE_SPEED;
                        score = Math.floor(score * 0.5); 
                        camera.position.x = (Math.random() - 0.5) * 3;
                        
                        // Flash Red
                        const oldFog = scene.fog.color.clone();
                        scene.fog.color.setHex(0xFF0000);
                        setTimeout(() => { scene.fog.color.copy(oldFog); }, 100);
                    }
                } else if (ob.mesh.position.z > 15) {
                    scene.remove(ob.mesh);
                    obstacles.splice(i, 1);
                }
            }

            // --- RINGS LOGIC ---
            for (let i = rings.length - 1; i >= 0; i--) {
                const r = rings[i];
                r.mesh.position.z += gameSpeed;
                r.mesh.rotation.z += 0.1; // Spin ring

                const distZ = Math.abs(r.mesh.position.z - player.position.z);
                const distX = Math.abs(r.mesh.position.x - player.position.x);
                
                // Ring hitbox slightly generous
                if (r.active && distZ < 2.0 && distX < 2.5) {
                    r.active = false;
                    scene.remove(r.mesh);
                    
                    // --- BOOST EFFECT ---
                    gameSpeed += 0.8; // Big Boost
                    score += 500;
                    invincibleTimer = INVINCIBILITY_DURATION; // Grant Invincibility
                    
                    // Flash White
                    const oldFog = scene.fog.color.clone();
                    scene.fog.color.setHex(0xFFFFFF);
                    setTimeout(() => { scene.fog.color.copy(oldFog); }, 50);

                } else if (r.mesh.position.z > 15) {
                    scene.remove(r.mesh);
                    rings.splice(i, 1);
                }
            }

            // Clean up arrays logic
            obstacles.forEach((o, index) => { if(!o.active && !o.mesh.parent) obstacles.splice(index, 1); });
            rings.forEach((r, index) => { if(!r.active && !r.mesh.parent) rings.splice(index, 1); });

            // Restore Player Z position
            player.position.z = THREE.MathUtils.lerp(player.position.z, 0, 0.1);
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, 0, 0.1);
            
            score += gameSpeed * 0.1;
            
            // --- SAVE CHECK ---
            if (score > highScore) {
                highScore = Math.floor(score);
                localStorage.setItem('excelerate_highscore', highScore);
            }
            
            updateUI();
        }

        function updateUI() {
            const speedPct = Math.floor((gameSpeed / MAX_SPEED) * 100);
            document.getElementById('score-display').innerText = `VELOCITY: ${speedPct}% | SCORE: ${Math.floor(score)}`;
            document.getElementById('streak-bar').style.width = `${Math.min(speedPct, 100)}%`;
        }

        // --- INPUT & EVENTS ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        const handleAction = () => {
            if (!isPlaying) return;
            playerDir *= -1;
            player.rotation.z = playerDir * 0.5;
        };

        window.addEventListener('pointerdown', (e) => {
            if (e.target.id === 'start-btn') startGame();
            else if (e.target.id === 'mute-btn') toggleMute();
            else handleAction();
        });

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (!isPlaying && document.getElementById('start-screen').style.display !== 'none') startGame();
                else handleAction();
            }
        });

        function toggleMute() {
            isMuted = !isMuted;
            const btn = document.getElementById('mute-btn');
            if (isMuted) {
                bgmSound.pause();
                btn.innerText = "UNMUTE";
            } else {
                if(bgmSound.buffer) bgmSound.play();
                btn.innerText = "MUTE MUSIC";
            }
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            isPlaying = true;
            score = 0;
            gameSpeed = BASE_SPEED;
            invincibleTimer = 0;
            
            obstacles.forEach(o => scene.remove(o.mesh));
            obstacles.length = 0;
            rings.forEach(r => scene.remove(r.mesh));
            rings.length = 0;
            
            playRandomMusic();
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            updatePhysics();
            updateColors();

            if(isPlaying && !isMuted && !bgmSound.isPlaying && !isLoadingMusic) {
                playRandomMusic();
            }

            composer.render();
        }

        document.getElementById('high-score-label').innerText = `BEST STREAK: ${highScore}`;
        animate();

    </script>
</body>
</html>
