<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EXCELERATE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; user-select: none; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        
        /* Text Styles */
        .hud-text { color: white; text-shadow: 0 0 10px rgba(255,255,255,0.8); letter-spacing: 2px; }
        #score-display { font-size: 2rem; font-weight: bold; transition: color 1s; }
        #streak-bar-container { width: 100%; height: 10px; background: rgba(255,255,255,0.2); margin-top: 10px; border-radius: 5px; overflow: hidden; }
        #streak-bar { width: 0%; height: 100%; background: white; box-shadow: 0 0 15px white; transition: width 0.1s linear, background-color 1s; }
        
        /* Menus */
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; pointer-events: auto; backdrop-filter: blur(5px); }
        h1 { color: white; font-size: 4rem; text-transform: uppercase; margin: 0; text-shadow: 0 0 20px white; font-style: italic; }
        .sub-text { color: #aaa; margin-top: 10px; font-size: 1.2rem; }
        #high-score-label { color: gold; margin-top: 20px; font-size: 1.5rem; text-shadow: 0 0 10px orange; }
        
        /* Buttons */
        .btn { border: 2px solid white; color: white; background: transparent; padding: 15px 40px; font-size: 1.5rem; margin-top: 30px; cursor: pointer; transition: 0.2s; font-family: inherit; text-transform: uppercase; font-weight: bold; }
        .btn:hover { background: white; color: black; box-shadow: 0 0 20px white; }
        
        #mute-btn { pointer-events: auto; background: transparent; border: 1px solid rgba(255,255,255,0.5); color: white; padding: 10px; font-family: inherit; cursor: pointer; opacity: 0.7; }
        #mute-btn:hover { opacity: 1; border-color: white; }

        canvas { image-rendering: pixelated; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div>
            <div id="score-display">SPEED: 0%</div>
            <div id="streak-bar-container"><div id="streak-bar"></div></div>
        </div>
        <div style="text-align: right;">
            <button id="mute-btn">MUTE MUSIC</button>
        </div>
    </div>

    <div id="start-screen">
        <h1>Excelerate</h1>
        <div class="sub-text">TAP / SPACE to Switch Direction</div>
        <div class="sub-text">Avoid Black Spikes to Build Speed</div>
        <div id="high-score-label">BEST STREAK: 0</div>
        <button id="start-btn" class="btn">IGNITE</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RenderPixelatedPass } from 'three/addons/postprocessing/RenderPixelatedPass.js';

        // --- CONFIGURATION ---
        // !!! UPDATE THIS LIST WITH YOUR ACTUAL FILE NAMES !!!
        const REPO_URL = "https://raw.githubusercontent.com/Jackboby/EXCELERATE/main/Song/";
        const SONG_FILES = [
            "Isaiah40.mp3", 
            "Psalm23.mp3"
        ];
        
        const COLOR_PALETTES = [
            { main: 0xFFFF00, bg: 0x222200 }, // Yellow
            { main: 0x00FFFF, bg: 0x002222 }, // Cyan
            { main: 0xFF00FF, bg: 0x220022 }, // Magenta
            { main: 0x00FF00, bg: 0x002200 }, // Green
            { main: 0xFF4400, bg: 0x221100 }  // Orange
        ];

        // --- GAME STATE ---
        let isPlaying = false;
        let isMuted = false;
        let score = 0;
        let highScore = localStorage.getItem('excelerate_highscore') || 0;
        
        // Physics
        let gameSpeed = 0;
        const BASE_SPEED = 0.5;
        const MAX_SPEED = 4.5;
        const ACCELERATION = 0.001; 
        
        let playerDir = 1; 
        const PLAYER_LATERAL_SPEED = 0.4;
        const LANE_WIDTH = 12;

        const obstacles = [];
        let obstacleTimer = 0;

        // Color Transitions
        const currentColor = {
            main: new THREE.Color(0xFFFFFF),
            bg: new THREE.Color(0x000000)
        };
        const targetColor = {
            main: new THREE.Color(0xFFFF00),
            bg: new THREE.Color(0x222200)
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 12);
        camera.lookAt(0, 0, -5);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- AUDIO SYSTEM ---
        const audioListener = new THREE.AudioListener();
        camera.add(audioListener);
        const bgmSound = new THREE.Audio(audioListener);
        let currentSongIndex = -1;
        let isLoadingMusic = false;

        async function playRandomMusic() {
            if(isLoadingMusic) return;
            isLoadingMusic = true;

            if(bgmSound.isPlaying) bgmSound.stop();
            
            // Random index different from current
            let newIndex;
            if (SONG_FILES.length > 1) {
                do {
                    newIndex = Math.floor(Math.random() * SONG_FILES.length);
                } while (newIndex === currentSongIndex);
            } else {
                newIndex = 0;
            }
            
            currentSongIndex = newIndex;
            setThemeTarget(currentSongIndex % COLOR_PALETTES.length);

            if(isMuted) {
                isLoadingMusic = false;
                return;
            }

            const loader = new THREE.AudioLoader();
            try {
                const buffer = await loader.loadAsync(REPO_URL + SONG_FILES[currentSongIndex]);
                bgmSound.setBuffer(buffer);
                bgmSound.setLoop(false); // Important: Don't loop same song
                bgmSound.setVolume(0.5);
                bgmSound.play();
            } catch (e) {
                console.warn("Could not load music:", e);
            }
            isLoadingMusic = false;
        }

        // --- VISUALS ---
        
        // Player
        const playerGeo = new THREE.OctahedronGeometry(0.8, 0);
        const playerMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff, 
            emissiveIntensity: 2.0,
            roughness: 0.1
        });
        const player = new THREE.Mesh(playerGeo, playerMat);
        scene.add(player);

        // Floor Grid
        const gridHelper = new THREE.GridHelper(200, 50, 0xffffff, 0x444444);
        gridHelper.position.y = -1;
        gridHelper.position.z = -50;
        gridHelper.scale.z = 5; 
        scene.add(gridHelper);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);

        // Post Processing
        const composer = new EffectComposer(renderer);
        const renderPixelatedPass = new RenderPixelatedPass(4, scene, camera);
        composer.addPass(renderPixelatedPass);

        const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- FUNCTIONS ---

        function setThemeTarget(paletteIndex) {
            const palette = COLOR_PALETTES[paletteIndex];
            targetColor.main.setHex(palette.main);
            targetColor.bg.setHex(palette.bg);
        }

        function createObstacle() {
            // Spiky geometry: Tetrahedron is sharpest simple geo
            const size = 1.5 + Math.random() * 1.5;
            const geo = new THREE.TetrahedronGeometry(size, 0);
            
            // PURE BLACK MATERIAL for silhouette look
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0x000000 
            });

            const mesh = new THREE.Mesh(geo, mat);
            
            // Random rotation for "jagged" variety
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            
            const xPos = (Math.random() - 0.5) * LANE_WIDTH * 1.5; 
            mesh.position.set(xPos, 0, -100); 
            scene.add(mesh);
            obstacles.push({ mesh, active: true });
        }

        function updateColors() {
            // Lerp current colors towards target colors (Smooth transition)
            const lerpSpeed = 0.02;
            
            currentColor.main.lerp(targetColor.main, lerpSpeed);
            currentColor.bg.lerp(targetColor.bg, lerpSpeed);

            // Apply colors
            scene.background.copy(currentColor.bg);
            scene.fog.color.copy(currentColor.bg);
            
            // Grid lines color
            gridHelper.material.color.copy(currentColor.main);
            
            // Bloom tint
            bloomPass.tintColor = currentColor.main;
            
            // UI Color
            const uiColorString = currentColor.main.getStyle();
            document.getElementById('score-display').style.color = uiColorString;
            document.getElementById('streak-bar').style.boxShadow = `0 0 15px ${uiColorString}`;
        }

        function updatePhysics() {
            if (!isPlaying) return;

            // Speed & Input
            if (gameSpeed < MAX_SPEED) gameSpeed += ACCELERATION;
            player.position.x += playerDir * PLAYER_LATERAL_SPEED;
            
            // Bounce Walls
            if (player.position.x > LANE_WIDTH) {
                player.position.x = LANE_WIDTH;
                playerDir = -1;
            } else if (player.position.x < -LANE_WIDTH) {
                player.position.x = -LANE_WIDTH;
                playerDir = 1;
            }

            // Player Animation
            player.rotation.y += 0.1;
            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, 0, 0.1);

            // Obstacle Spawning
            obstacleTimer -= gameSpeed;
            if (obstacleTimer <= 0) {
                createObstacle();
                obstacleTimer = 40 / (gameSpeed + 0.1); 
            }

            // Grid movement
            gridHelper.position.z += gameSpeed;
            if(gridHelper.position.z > 0) gridHelper.position.z = -50;

            // Obstacle Logic
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const ob = obstacles[i];
                ob.mesh.position.z += gameSpeed;
                
                // Rotation for spiky effect
                ob.mesh.rotation.x += 0.02;
                ob.mesh.rotation.y += 0.02;

                // Collision
                const distZ = Math.abs(ob.mesh.position.z - player.position.z);
                const distX = Math.abs(ob.mesh.position.x - player.position.x);
                const hitSize = 1.5; // Approx hitbox

                if (ob.active && distZ < hitSize && distX < hitSize) {
                    ob.active = false;
                    player.position.z -= 2; 
                    gameSpeed = BASE_SPEED;
                    score = Math.floor(score * 0.5); 
                    
                    camera.position.x = (Math.random() - 0.5) * 3;
                    
                    // Flash Red
                    const oldFog = scene.fog.color.clone();
                    scene.fog.color.setHex(0xFF0000);
                    setTimeout(() => { scene.fog.color.copy(oldFog); }, 100);

                } else if (ob.mesh.position.z > 15) {
                    scene.remove(ob.mesh);
                    ob.mesh.geometry.dispose();
                    ob.mesh.material.dispose();
                    obstacles.splice(i, 1);
                }
            }

            // Stability
            player.position.z = THREE.MathUtils.lerp(player.position.z, 0, 0.1);
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, 0, 0.1);
            
            score += gameSpeed * 0.1;
            updateUI();
        }

        function updateUI() {
            const speedPct = Math.floor((gameSpeed / MAX_SPEED) * 100);
            document.getElementById('score-display').innerText = `VELOCITY: ${speedPct}% | SCORE: ${Math.floor(score)}`;
            document.getElementById('streak-bar').style.width = `${speedPct}%`;
        }

        // --- INPUT & EVENTS ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        const handleAction = () => {
            if (!isPlaying) return;
            playerDir *= -1;
            player.rotation.z = playerDir * 0.5;
        };

        window.addEventListener('pointerdown', (e) => {
            if (e.target.id === 'start-btn') startGame();
            else if (e.target.id === 'mute-btn') toggleMute();
            else handleAction();
        });

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (!isPlaying && document.getElementById('start-screen').style.display !== 'none') startGame();
                else handleAction();
            }
        });

        function toggleMute() {
            isMuted = !isMuted;
            const btn = document.getElementById('mute-btn');
            if (isMuted) {
                bgmSound.pause();
                btn.innerText = "UNMUTE";
            } else {
                if(bgmSound.buffer) bgmSound.play();
                btn.innerText = "MUTE MUSIC";
            }
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            isPlaying = true;
            score = 0;
            gameSpeed = BASE_SPEED;
            obstacles.forEach(o => scene.remove(o.mesh));
            obstacles.length = 0;
            playRandomMusic();
        }

        function saveGame() {
            if (score > highScore) {
                highScore = Math.floor(score);
                localStorage.setItem('excelerate_highscore', highScore);
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            updatePhysics();
            updateColors();

            // Music Loop Check: If song ended, play next
            if(isPlaying && !isMuted && !bgmSound.isPlaying && !isLoadingMusic) {
                playRandomMusic();
            }

            composer.render();
        }

        document.getElementById('high-score-label').innerText = `BEST STREAK: ${highScore}`;
        animate();

    </script>
</body>
</html>
